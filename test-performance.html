<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xian Wallet Performance Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 3px;
        }
        .success { background-color: #d4edda; }
        .warning { background-color: #fff3cd; }
        .error { background-color: #f8d7da; }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 3px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #results {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Xian Wallet Performance Test Suite</h1>
    
    <div class="test-section">
        <h2>Template Loading Performance</h2>
        <button onclick="testTemplateLoading()">Test Template Loading</button>
        <div id="template-results"></div>
    </div>

    <div class="test-section">
        <h2>Crypto Operations Performance</h2>
        <button onclick="testCryptoOperations()">Test Crypto Operations</button>
        <div id="crypto-results"></div>
    </div>

    <div class="test-section">
        <h2>External Window Creation</h2>
        <button onclick="testWindowCreation()">Test Window Creation</button>
        <div id="window-results"></div>
    </div>

    <div class="test-section">
        <h2>Main Thread Monitoring</h2>
        <button onclick="startMainThreadTest()">Start Main Thread Test</button>
        <button onclick="stopMainThreadTest()">Stop Main Thread Test</button>
        <div id="thread-results"></div>
    </div>

    <div id="results"></div>

    <!-- Include necessary scripts -->
    <script src="js/providers/nacl.js"></script>
    <script src="js/performance-monitor.js"></script>
    <script src="js/template-cache.js"></script>
    <script src="js/crypto-worker-manager.js"></script>
    <script src="js/pyodide-worker-manager.js"></script>

    <script>
        let mainThreadTestInterval;
        
        // Test template loading performance
        async function testTemplateLoading() {
            const resultsDiv = document.getElementById('template-results');
            resultsDiv.innerHTML = '<div class="test-result">Testing template loading...</div>';
            
            const templates = [
                'templates/wallet.html',
                'templates/settings.html',
                'templates/request-transaction.html'
            ];
            
            let results = [];
            
            for (const template of templates) {
                try {
                    // Test without cache
                    const startTime = performance.now();
                    const response = await fetch(template);
                    const content = await response.text();
                    const noCacheTime = performance.now() - startTime;
                    
                    // Test with cache
                    const cacheStartTime = performance.now();
                    const cachedContent = await templateCache.getTemplate(template);
                    const cacheTime = performance.now() - cacheStartTime;
                    
                    results.push({
                        template,
                        noCacheTime: noCacheTime.toFixed(2),
                        cacheTime: cacheTime.toFixed(2),
                        improvement: ((noCacheTime - cacheTime) / noCacheTime * 100).toFixed(1)
                    });
                } catch (error) {
                    results.push({
                        template,
                        error: error.message
                    });
                }
            }
            
            // Display results
            let html = '';
            results.forEach(result => {
                if (result.error) {
                    html += `<div class="test-result error">
                        <strong>${result.template}</strong>: Error - ${result.error}
                    </div>`;
                } else {
                    const cssClass = parseFloat(result.improvement) > 0 ? 'success' : 'warning';
                    html += `<div class="test-result ${cssClass}">
                        <strong>${result.template}</strong><br>
                        No cache: ${result.noCacheTime}ms<br>
                        With cache: ${result.cacheTime}ms<br>
                        Improvement: ${result.improvement}%
                    </div>`;
                }
            });
            
            resultsDiv.innerHTML = html;
        }
        
        // Test crypto operations performance
        async function testCryptoOperations() {
            const resultsDiv = document.getElementById('crypto-results');
            resultsDiv.innerHTML = '<div class="test-result">Testing crypto operations...</div>';
            
            const testPassword = 'testpassword123';
            let results = [];
            
            try {
                // Test key pair generation
                const keyGenStart = performance.now();
                const keyPair = nacl.sign.keyPair();
                const keyGenTime = performance.now() - keyGenStart;
                
                results.push({
                    operation: 'Key Pair Generation',
                    time: keyGenTime.toFixed(2),
                    status: 'success'
                });
                
                // Test encryption
                const encryptStart = performance.now();
                const encrypted = await measureCryptoOperation('Private Key Encryption', async () => {
                    // Simulate encryption operation
                    const passwordBytes = new TextEncoder().encode(testPassword);
                    const hash = nacl.hash(passwordBytes);
                    const key = hash.slice(0, 32);
                    const nonce = nacl.randomBytes(24);
                    return nacl.secretbox(keyPair.secretKey, nonce, key);
                });
                const encryptTime = performance.now() - encryptStart;
                
                results.push({
                    operation: 'Private Key Encryption',
                    time: encryptTime.toFixed(2),
                    status: 'success'
                });
                
                // Test signing
                const signStart = performance.now();
                const message = new TextEncoder().encode('test message');
                const signature = nacl.sign.detached(message, keyPair.secretKey);
                const signTime = performance.now() - signStart;
                
                results.push({
                    operation: 'Message Signing',
                    time: signTime.toFixed(2),
                    status: 'success'
                });
                
            } catch (error) {
                results.push({
                    operation: 'Crypto Test',
                    error: error.message,
                    status: 'error'
                });
            }
            
            // Display results
            let html = '';
            results.forEach(result => {
                const cssClass = result.status === 'success' ? 'success' : 'error';
                if (result.error) {
                    html += `<div class="test-result ${cssClass}">
                        <strong>${result.operation}</strong>: Error - ${result.error}
                    </div>`;
                } else {
                    html += `<div class="test-result ${cssClass}">
                        <strong>${result.operation}</strong>: ${result.time}ms
                    </div>`;
                }
            });
            
            resultsDiv.innerHTML = html;
        }
        
        // Test window creation performance
        async function testWindowCreation() {
            const resultsDiv = document.getElementById('window-results');
            resultsDiv.innerHTML = '<div class="test-result">Testing window creation...</div>';
            
            try {
                const startTime = performance.now();
                
                // Simulate window creation process
                const windowCreationTime = await measureWindowCreation('External Window', async () => {
                    // Simulate the window creation delay
                    await new Promise(resolve => setTimeout(resolve, 100));
                    return true;
                });
                
                const totalTime = performance.now() - startTime;
                
                resultsDiv.innerHTML = `
                    <div class="test-result success">
                        <strong>Window Creation Test</strong><br>
                        Total time: ${totalTime.toFixed(2)}ms<br>
                        Status: Success
                    </div>
                `;
                
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="test-result error">
                        <strong>Window Creation Test</strong>: Error - ${error.message}
                    </div>
                `;
            }
        }
        
        // Start main thread monitoring test
        function startMainThreadTest() {
            const resultsDiv = document.getElementById('thread-results');
            resultsDiv.innerHTML = '<div class="test-result">Monitoring main thread blocking...</div>';
            
            let blockingEvents = [];
            let startTime = performance.now();
            
            // Override console.warn to capture blocking events
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && args[0].includes('Main thread blocked')) {
                    blockingEvents.push({
                        time: performance.now() - startTime,
                        message: args[0]
                    });
                }
                originalWarn.apply(console, args);
            };
            
            // Simulate some heavy operations
            mainThreadTestInterval = setInterval(() => {
                // Simulate blocking operation
                const start = Date.now();
                while (Date.now() - start < 20) {
                    // Busy wait to block main thread
                }
            }, 1000);
            
            // Store original console.warn for restoration
            window.originalConsoleWarn = originalWarn;
            window.blockingEvents = blockingEvents;
            window.testStartTime = startTime;
        }
        
        // Stop main thread monitoring test
        function stopMainThreadTest() {
            if (mainThreadTestInterval) {
                clearInterval(mainThreadTestInterval);
                mainThreadTestInterval = null;
            }
            
            // Restore original console.warn
            if (window.originalConsoleWarn) {
                console.warn = window.originalConsoleWarn;
            }
            
            const resultsDiv = document.getElementById('thread-results');
            const blockingEvents = window.blockingEvents || [];
            
            if (blockingEvents.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="test-result success">
                        <strong>Main Thread Test</strong><br>
                        No blocking events detected during test period.
                    </div>
                `;
            } else {
                let html = `<div class="test-result warning">
                    <strong>Main Thread Test</strong><br>
                    Detected ${blockingEvents.length} blocking events:<br>
                `;
                
                blockingEvents.forEach((event, index) => {
                    html += `${index + 1}. ${event.message} (at ${event.time.toFixed(0)}ms)<br>`;
                });
                
                html += '</div>';
                resultsDiv.innerHTML = html;
            }
        }
        
        // Initialize performance monitoring
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Performance test page loaded');
            performanceMonitor.logSummary();
        });
    </script>
</body>
</html>